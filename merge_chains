#!/usr/bin/env python3
"""
Merge multiple chain files into a single chain file.
"""

import uproot
import diagnostics as dg
from tqdm import tqdm
import numpy as np

def get_files(directory, max_files=None):
  import os

  if not directory.endswith("/"):
    directory += "/"

  files = []
  for file in os.listdir(directory):
    if file.endswith(".root"):
      
      if max_files is not None and len(files) >= max_files:
        break
      
      files.append(directory + file)
  return files

def parse_arguments():
  import argparse
  from argparse import RawTextHelpFormatter

  parser = argparse.ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)
  parser.add_argument("files", type=str, help="Directory with the chains")
  parser.add_argument("--burn-in", type=int, default=0, help="Burn-in for the chains (default: 0)")
  parser.add_argument("--thin", type=int, default=1, help="Thinning factor for the chains (default: 1)")
  parser.add_argument("--max-steps", type=int, default=None, help="Maximum number of steps to read from each chain (default: all)")
  parser.add_argument("--max-files", type=int, default=None, help="Maximum number of files run the diagnostics over")

  parser.add_argument("--output", type=str, default="merged_chain.root", help="Output file name (default: merged_chain.root)")

  parser.add_argument("--include-systematics", action="store_true", help="Include systematics parameters in the diagnostics (default: False)")

  parser.add_argument("--keep-branches", type=str, nargs="+", default=[], help="List of branches to keep in the merged chain (default: all non-ignored branches)")
  parser.add_argument("--ignore-branches", type=str, nargs="+", default=[], help="List of branches to ignore in the merged chain (default: none)")

  return parser.parse_args()

def process_chains(metadata, burn_in, thin, max_steps, include_systematics, output_file, keep_branches, ignore_branches):
  print(f"Processing {len(metadata.files)} files with burn-in={burn_in}, thin={thin}, max_steps={max_steps}, include_systematics={include_systematics}")
  # Find all the branches from the first file
  with uproot.open(metadata.files[0]) as f:
    example_chain = f[metadata.ttree_location]
    all_branches = [key for key in example_chain.keys()]
    keys = [key for key in example_chain.keys() if key not in metadata.ignored_branches]
  
  # All of the branches that are not "metadata.ignored_branches" or "metadata.key_branches" are considered systematics
  if not include_systematics:
    print("Excluding systematic branches from the merged chain")
    keys = [key for key in keys if key in metadata.key_branches]

  # If keep_branches is not empty, keep those branches, even if excluded by the previous criteria 
  if keep_branches:
    keys = list(set(keys) | set(keep_branches))
  
  # If ignore_branches is not empty, ignore those branches
  if ignore_branches:
    keys = [key for key in keys if key not in ignore_branches]
  
  print(f"All available branches ({len(all_branches)}): {all_branches}")
  print(f"Final list of branches to keep ({len(keys)}): {keys}")
  
  with uproot.recreate(output_file) as fout:
    fout.mktree(metadata.ttree_location, {branch: np.float64 for branch in keys})

    for filename in tqdm(metadata.files, desc="Merging chains"):
      for arrays in uproot.iterate(
          f"{filename}:{metadata.ttree_location}",
          keys,
          library="np"
      ):
        # Apply burn-in, thinning, and max_steps
        arrays = {key: val[burn_in:max_steps:thin] for key, val in arrays.items()}

        fout[metadata.ttree_location].extend(arrays)

if __name__ == "__main__":

  # Get all the arguments
  args = parse_arguments()

  # Get the list of files to process
  files = get_files(args.files, args.max_files)

  # Get the metadata from the files
  metadata = dg.SamplerMetadata(files)

  metadata.print_metadata()

  # Process the chains
  process_chains(metadata, args.burn_in, args.thin, args.max_steps, args.include_systematics, args.output, args.keep_branches, args.ignore_branches)